## Пример проекта под МК STM32F405 на C++ с использованием библиотеки m.

1. Arm GNU Toolchain 13.3.Rel1 + Vscode + Embedded IDE plugin.
2. Форматирование кода .clang-format Google.
3. Стиль кода в основном опирается на "Руководство Google по стилю в C++" (Google C++ Style Guide: https://google.github.io/styleguide/cppguide.html).
4. Не используются: макросы, выделение памяти, RTTI, исключения.
5. Конфигурация периферии МК - полность из CubeMX.
6. main.cpp - основной, main.c исключён из проекта (генерируется автоматически из CubeMX).
7. RTOS не используется.

## Базовые принципы:
1. Для уменьшения связности кода и абстракции от конкретного МК используются интерфейсы.
2. Вместо наследования предпочитается композиция (за исключением интерфейсов).
3. Логика работы устройства реализуется на конечных автоматах.
4. Логика реализуется в неблокирующем режиме, что позволяет без изменений перенести её выполнение на RTOS.
5. Вместо выделения памяти в куче используется `std::array<uint8_t>` в качестве буфера на стеке с дальнейшей передачей через `std::span<uint8_t>`
в соответствующий класс. В крайнем случае используется аллокатор на стеке `short_alloc.h` от Howard Hinnant.

## Краткое описание:
1. Все задержки, таймауты и т.д. базируются на основе классов `TimeUs`, `TimeMs`, которые в свою очередь являются реализациями интерфейсов
  ` m::ifc::ITime<Us<uint32_t>>` и `m::ifc::ITime<Ms<uint32_t>>` и предоставлют доступ к отсчёту времени с момента запуска МК в микросекундах и миллисекундах.
Основаны на таймере TIM5 и SysTick.
2. Для работы с GPIO используется класс `PinWrapper`, наследуемый от `m::ifc::mcu::IPin`.
Предоставляет базовый  функции `read()`,`wirte()`,`toggle()`
3. Для измерения температуры используется класс `Adc_1` наследуемый от `m::ifc::mcu::IAdcDmaCircularReader<uint16_t> ` и класс `Ntc`.
`Adc_1` реализует запуск АЦП в цикличном DMA режиме с прерываниями при заполнении половины и полного буфера. По прерыванию в пользовательских коллбэках идёт фильтрация данных.
Класс `Ntc` наследуется от `m::ifc::ITempSense<std::optional<Celsius<float>>>` и `m::ifc::ITempSenseError` и реализует пересчёт измеренного напряжения в сопротивление ntc термистора, а далее в температуру в градусах Цельсия.
4. Библиотечный класс `m::ic::PY25Q128HA`, наследуемый от интерфейса `m::ifc::IMemory`, реализует функции чтения\записи в память на основе микросхемы PY25Q128HA. Сам класс оперирует интерфейсом синхронного ввода\вывода `m::ifc::IIO_Sync<Ms<type>>`, в данной реализации это класс `Spi_1`, реализующий блокирующую передачу данных по SPI с применением DMA.
5. Приём и обработка команд по Modbus RTU реализуется в библиотечном классе `m::ModbusRtuProtocol<Us<uint32_t>>`, при приёме соответствующих команды вызываются пользовательские коллбэки для их обработки. Приёмопередача пакетов осуществляется в классах `Usart_5` & `Usart_4`, наследуемых от `m::ifc::IIO_Async` и реализующих асинхронный приём и передачу байт c использованием DMA. Для разделение байт в шине на пакеты используется класс `m::DataLinkAsync<Us<uint32_t>>`, наследуемый от интерфейса `m::ifc::IDataLink` и реализующий отделение пакетов на основе временных задержек.
6. Вместо RTOS используется прерывание с частотой 1кГц, в котором вызывается обработка команд Modbus RTU. Для этого используется класс `Tim_7_1kHz` наследуемый от `m::ifc::mcu::IIt` и реализующий вызов пользовательского коллбэка при срабатывании прерывания.
7. Конечный автомат и некоторая другая логика работают в основном бесконечном цикле.
8. Для логирования по USART используется библиотечный класс `m::IIO_AsyncLog`, работающий с классом `Usart_1`.
9. Для определения мест и последовательности возникновения ошибок используется  библиотечный класс `m::SimpleErrorTracer<uint16_t, 100>`.
